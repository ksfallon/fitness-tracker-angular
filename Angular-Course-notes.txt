1. Angular is a javascript framework, that uses TypeScript
    a. TypeScript - very similar to JS with alot of the same syntax, just it has some extra stuff:
    - still have: classes, properties, decorators, interfaces,
    b. Client side (Browser side) web applications
    - Single-Page-applications (SPAs) - its like a native-mobile-app-like User Experience
    c. highly-scalable, high performance,allows for you to build a big applications
    d. continuously developed and supported by google

2. Core Concepts
    a. one single HTML page (index.html) which is continuously re-rendered by angular
    b. the whole website is made up of components
        ex: header component, sidebar component, item component
        - in the end a component is just a template in which we have:
            - html code which in enhanced with special angular syntax.
            - typescript page - where we right the logic for the components
            - there are directives - allow us to manipulate the content of the template
                - *ngFor - four loops that can render huge amounts of code to a page
            - css & test pages are also autogenerated for each component.
    c. Services - these are needed to everything to communicate

3. Main.ts (src/main.ts - the main ts file that gets everything to run
  - import a few things from the angular package
  -
  - calls on AppModule on line 11 (and imports ir on line 4 from app/app.module )
    - its passed through bootstrapModule(AppModule) - which means start it on its own without any other help
      - here is the whole line - platformBrowserDynamic().bootstrapModule(AppModule)
    - AppModule is like the root file that defines all of the pieces that our Angular app is made up of
4. AppModule (scr/app/app.module.ts) -
  - we have imports, a type script class called AppModule that has no body, and @NgModule{}
  - @NgModule is a type of DECORATOR
    - ** A DECORATOR that is a ts feature that kind of manipulates the class (here AppModule) behind the scenes - it adds some metadata **
    - NgModule is a special decorator that is imported from the angular pacakge and it turns a normal type script class into a Module, its additional metadata allows it to be interpreted by Angular as a Model.
    - the object has declarations, imports, and providers that are DEFINITIONS/CONFIGURATIONS contain this metadata:
      - a declarations array declars all of the components that you are using in your project.
      - imports, imports other modules, like the BrowserModule seen here.
      - providers is used to provide services - something we'll come back to.
      - *bootstrap is a special one here bc it informs our app that AppComponent is the root component of the application
        - this is partially how it app.component is connected to the root-tag (app-root) in the index.html file.
        - if you go into app.component.ts you'll see in the Component decorator that selector is 'app-root'

Lecture 11 - ADDING COMPONENTS
** breaking things down so you have SMALL MANAGABLE PIECES to your app. - best way to debug

1. App.component.ts CONTINUED...:
- A component is a building block of our app. each one is made of:
  - a typescript class that for app.component.ts is 'AppComponent'
  - a decorator called 'Component' decorator which is imported from angular core.
    - the decorator has metadata that makes the class more than just a class and is understood by Angular to be a component that should be rendered to the UI/screen.
    - 'templateUrl' - each component decorator must have this so there is content to actually render to the screen, bc it is the html file it is connected to.
      - this html file, its like html ++ bc it allows you to add special syntax like {{}} (string interpolation) which outputs dynamic content
    - 'styleURL' - which is optional, and points at the css file that is unique to this particular component.
    -'selector' maybe the most important - bc it is essentially the component's own 'HTML TAG'.
      - you can use this tag to put this component's template into other components' templates.

2. ng g c 'your component name here' will generate a component folder with:
  - the component ts, html, css and test files
  - it will connect it in app.modules.ts under @NgModule in declarations and import it there too so its called.
  - g is short for generate and c is short for component

3. String interpolation, event binding, property binding, Two way binding.
  - String interpolation - {{ prop }} - allows us to refer to a property (prop) of our typescript class and output its content in the html template
    - these props - which can be variables or fucntions - are located in the class component in the TS file.
    - they can be set dynamically in the class as well - example here uses setTimeout to have the variable change after 3 seconds.
  - event binding - an example is 'click', but there are LOTS - that is added the the html element:
    - <button (click)="">Click here</button>
      - between the " " - (click)="" - its not actually TEXT, its a reference to the function that should happen when the click takes place
      - ** the info between the "" is interpreted as type script code.
      - EX: (click)="productName = 'A Tree'" - when clicked product name changes to 'A Tree', need the single quotes to show the string that equals productName.
  - property binding - every html element has an underlying DOM element which is just a JS object with properties
    - ex: <button></button> has a built in property called 'disabled' which determines whether the button is disabled or not.
    - its sets the value of a property of an underlying dom object.
    - we can bind to that property by adding brackets around it and assign a dynamic prop/value to it too
      -<button (click)="productName = 'A Tree'" [disabled]="isDisabled">Click here</button>
      - in the TS you need to add property "isDisabled", if its set to "true" then it IS disabled and you can't click the button.
        - but maybe we use the setTimeout property so that button starts as isDisabled = true, but after 3 seconds we want to let the user click it so set isDisabled = false.
  - two way binding - combo of property AND event binding - so use [] and () = [()] and within we put [(ngModel)]
    - ngModel is a special directive provided by Angular.
    - <input type="text" [(ngModel)]="productName"> - this insures whatever us typed into the input will be updated by ngModel as the new productName
    - *** for ngModel to work *** must go to app.module.ts and first IMPORT it:
      -import {FormsModule} from 'angular/forms';
      - then inside go to NgModule DECORATOR and put it in the imports list.

LECTURE 12 - Directives: *ngFor & *ngIf
Structural directives that really change the structure of our page by adding and removing elements.
1. *ngFor:
  - currently our button just changes the current prop, it doesn't add anything.
  - change the button click to a function that adds a product instead of updating the productName property.
  <button (click)="onAddProduct()">Add Product</button> (inside products.component.html)
  - now we need to add the onAddProduct function as a method to the products.component.ts inside the class ProductsComponent.
  - because we want to add more than one product - we need to set a property equal to an array.
    - products = ['A Book', 'A Tree'] - this is still locating insde the class, above the constructor with the other variables.
  - Here is how the onAddProduct function looks:
    onAddProduct() {
      this.products.push(this.productName);
    }
    - this refers to the class ProductsComponent
    - we just created the products array
    - and we want to push the new productName into the products array - we have productName as the input.
  - Currently we have a single div to show the current productName.
  - BUT NOW we want to have a div autogenerated every time we add a new product.
  -** we will us a DIRECTIVE called *ngFor (aka a for loop).
    - the start *ngFor is required bc it tells the app that this is a structural directive that will change the app.
    - here is the language we MUST use:
    <div *ngFor="let product of products">{{ product }}</div>
    - let, just like es6 variables definitions,
    - product, totally up to you what you put here as the index for your array
    - of products, this is NOT up to you because it refers to the array you want to run the forloop through.
    - {{ product }} is where the individual 'product' of products will be placed.
    - so now each product within products will have its own div!

2. *ngIf
  - an *ngIf is based on a property that is true or false so a BOOLEAN.
  - IT ALLOWS US TO CONDITIONALLY RENDER SOMETHING - based on that boolean.
  - So for our example - we want to conditionally render our BUTTON.
  - we dont want to disable OR enable the button but we want to show it once "isDisabled" is false
  - *ngIf will ADD or REMOVE the html element it is placed into based on the boolean.
  here is our example with the button:
  <input *ngIf="!isDisabled" type="text" val[(ngModel)]="productName">
  <button *ngIf="!isDisabled" (click)="onAddProduct()">Add Product</button>
    - between the ngIf quotes we SPECIFY the CONDITION (it has to be somethign that returns TRUE or FALSE):
      - We want isDisabled to be false. so we put a ! infront of it to make it "not isDisabled" or reverse it.
      - we add this same ngIf to the button.
      - this works because in our products.component.ts the prop isDisabled is set to true
        -SO whenever isDisabled isn't itself (ie !isDisabled is is FALSE) the input and button will appear.
        - and our setTimeout will set isDisabled = false AFTER 3 seconds.
        - which means after 3 seconds, isDisabled will equal false AKA !isDisabled.

LECTURE 14 - Custom Property & Event Binding
* Now we want to put each of these new products we created into through own components -
  - That way we can add buttons, explanations, and alot more!
  - so we are going to grab the div we created and go to the product.component.html template
  - in the product.component.html we remove the ngFor and just have {{ productName}} within the div we created.
    - might at <p>An Awesome Product</p>
    - wrap the div and the p in the article element so we can add some styling - in product.component.css
    - <article class="product"> so in the css file we can call on product and change it some.
  - we add productName as a property in the product.component.ts under the class:
    - But the data for productName has to come from the outside - it has to come from our ProductsComponent (parent component).
    - productName: string; - we know its a string so its good to define it here
    - ** we need to make it BINDABLE from outside, so we will use the [] brackets like we did for the html elements **
    - we do this with the "Input" decorator we also import from the angular/core package
    - @Input() productName: string; -*** THIS WILL BE EXPLAINED ON NEXT LINE ***
  - Input: is a decorator imported from the angular/core **used to recieve data from the outside
    - place @Input() before the property you are trying to import from another component
      - @Input() productName: string;
    - now we can go into products.component.html and add:
    <app-product *ngFor="let product of products" [productName]="product"></app-product>
      - so w/ app-product we call on the html of the ProductComponent (child component).
      - we still do our ngFor to declare product of products (From the ProductsComponenet (parent component))
      - with square brackets around [productName], now "product" from our array (inside parent component) is BOUND to the productName property (child component) and can be passed into the product.component (child component).
    - So the parent component can go into the child component this way

  - Now we'll add a click event so the child component can talk to the parent component.
  - in product.component.html add a click event to Change something in the ProductsComponent(parent component)
    - and this click event will EVENTUALLY call on a function in the parent component (ProductsComponent).
    <article class="product" (click)="onClicked()">
    - 1ST - need to create onClicked function in the child (ProductComponent) ts file.
    ** this is where we'll call on a function in the parent component (ProductsComponent)
    - but to do this we need to import "EventEmitter" and "Output" from the angular core
  - EventEmitter: we emit our own custom events with it.
  - Output: another decorator - used to pass data to the outside
    **BACK TO product.component.ts**
    - first create our object that will be our new eventEmitter:
      productClicked = new EventEmitter();
      - to be able to listen to it from the outside we must add our Output decorator to the front:
      @Output() productClicked = new EventEmitter();
        - output is used here to pass our custom eventEmitter to products.component
    -now can finally create our onClicked function:
    onClicked() {
      this.productClicked.emit();
    }
    -NOW all we need to do is LISTEN to this event (productClicked) in ProductsComponent - specifically the html page
      -once its there we can execute any code we want in the productsComponent:
      <app-product (productClicked)="onRemoveProduct(product)" *ngFor="let product of products" [productName]="product"></app-product>
      - we decided to call on "onRemoveProduct()" when the event emitter productClick is activated, and we are passing that product of products through it.
      - must create this function onRemoveProduct in products.component.ts (parent)
        onRemoveProduct (productName: string) {
          this.products = this.products.filter(p => p !== productName);
        }
        - we know that product is equal to productName, and we call its type (string) bc its best practice and to make sure the function knows its type.
          ** this is a little confusing with the productName in product.component.ts - try not to worry to much about this**
        - we call on this.products (ProductsComponent.products) and then .filter it - it will do this function we create within the () on each item in the array.
        (p => p !== productName);
        - for each product only keep it if the product is NOT equal to productName. if it IS EQUAL we want to get rid of it.
        - that will create a NEW array and that is while the whole line is first set to "this.products ="
        - Now we can remove the books based on their name!

    - What we just did is custom event binding - common for cross-component communication.

LECTURE 15 FORMS:
  - Go into the parent component - ProductsComponent - to create our FORM
  - we already have a very simple form bc we have an input and a button
  - BUT when we put them between the form tags in HTML somethings change
  - <form></form> - action will autogenerate inside the form tag but we can delete it for now.
  - place <input></input> and <button></button> between the form tags in HTML
    (we got rid of the disabled function for the input and button bc not needed anymore - was more to show how they work.)
  - ** We can remove out click listner from out Button now.
    - Instead we set button to 'type="submit"'
    - This submits the form and sends a request to the server (not what we want right now)
    -** we imported the FormsModule in app.module.ts - so Angular automatically detects the html forms tags and manages it for us behind the scenes.
      - This means it will prevent this form submission if we don't want it to
      - and we can prevent it by adding a SPECIAL EVENT
      - Angular also manages the validity of the state of the form, so if the values we enter are valead or not, and so on.
      - Special event: (ngSubmit), and attach it to a new function:
        <form (ngSubmit)="onAddProduct()">
        ** Whenever we submit the form, onAddProduct will be executed.**
  - We can also delete the two way binding from input: [(ngModel)]="productName"
    - Instead put ngModel which will just register the input as a control to angular: meaning it will say angular please keep track of this and its value.
    - We also need to assign a 'name' to the input tag, so 'name="productName"'
    - can also say 'required' so angular can say invalid values if an empty form is submitted.
  - Behind the scenes, now Angular is storing a JS object (our form input) with loads of info about it.
    - To see this object info in the console we can do this:
    - in the form add '#f' which by default gives us access to the underlying html element.
    - BUT by assiging it equal to ngForm: '#f="ngForm"' - Angular detects this syntax and gives us access tothe form object it created implicitly behind the scenes.
    - if we then pass f as an argument to onAddProduct(f), we can write the function in the products.component.ts file and console.log it.
    - so we already have an onAddProduct - just comment out the "this.products.push(this.productName) for now
    and put "console.log(form), and pass form through the function: onAddProduct(form)
    - Now on the website when you click "Add Product" inside the inspect/console you can see the NgForm object!
      - this is the form object Angular managed
      - it contains values like "valid" which is a boolean - true if something is entered, false if nothing was submitted BC we required it in the input html element.
      - it also have "value" which is the object with key value pairs:
        - productName: "A Tree" (whatever the input was)
        - the Key is the name of the form control (<input name="productName">)
        - Value is what we enter in the input area.
      - there are LOADS of other things here too to look at.
    - NOW LETS ADD THE COMMENTED LINE BACK IN with an updated submission!!
    onAddProduct(form) {
      if (form.valid) {
        this.products.push(form.value.productName);
      }
    }
    -** productName is the name of the control we assigned to the input html element **
    - Now we get the same behaviour we have before, BUT now its through Angular FORMS

LECTURE - Understanding Services & Dependency Injections

Services - are typescript classes that can be reached from any component.
  - This is B/C they can be INJECTED into any component and even into other services.
  - Its a TS Class so at the top of the function we:
  export class ProductsService {}
  - it holds functionality that you typically want to be able to share across multiple components.
    - this could be: data you want to use from other components, it could be utility functions like logging something or sending HTTP requests.
    1st. we'll create our products array: "private products = ['A Book']"
    2nd. We'll add two methods: addProducts and getProducts
      - addProducts will pass productName which is a string and it will push this product name into this.products
        addProducts(productName: string) {
          this.products.push(productName);
        }
      -getProducts will return the products array and use the spread operator (...) to pull out all of the old elements from this.products and add them as new elements to this new array.
        getProducts() {
          return [...this.products]
        }
        - if returned without the (...) we would just be pointing to the class above, NOT the additional information we've added from the user face. It also means we won't be changing the 'private products = ['A Book'] array wthin the class.
    3rd. Now that its setup - lets use it to create new products, which means it must be INJECTED somewhere.
    ** TO INJECT ProductsService INTO ProductsComponent
    - import ProductsService at the top of ProductsComponent
    - go the ProductsComponent's CONSTRUCTOR and PASS -> productsService: ProductsService through the parentheses.
      - it will be recognized by the constructor b/c we've already imported it.
    - ** These two things tell Angular that: it needs the productsService argument with the type -> ProductsComponent - so angular will try to give me an instance of this type.
    BUT for it to know how to do this, we must add something to the AppModule
    - first import the ProductsService at the top of AppModule
    - then in the providers array in the @NgModule object, we need to put anything that we want to inject anywhere in the app.
      - in providers array now we can put [ProductsService].
    NOW Angular can resolve this dependency and create a new instance of it and provide it in the constructor function of ProductsComponent.
    - If you run it rhough the constructor as "private productsService: ProductsService" it will not only be received as an arguement, but automatically bind it to a class property.
    - now in the onAddProduct function of ProductsComponent, instead of pushing to a local array we can adjust the function to bind is to the ProductsService 'addProduct' and push form.value.productName to ProductsService products array.
      onAddProduct(form) {
        if (form.valid) {
          this.productsService.addProduct(form.value.productName)
        }
      }
    - Now the products that are held are being stored in a more 'global' array.
    - We want to be able to use this more global array of products now too (this example isnt best practuce but gives the basic idea)
      - inside the constructor, set this.products = this.productsService.getProducts()
      - and the products variable (in ProductsComponent) set it equal to an empty array.
    - BUT THE BEST PLACE FOR THIS IS THE ONINIT (OnInit).
    - OnInit has to be imported at the top (still in ProductsComponent)
    - in the export class line after ProductsComponent add: "implements OnInit"
    - AND add a new method called: ngOnInit () - it runs it once its created the component AND after its run the constructor.
      - its very good practice to do anything but very trivial intializations inside NgOnInit.
      - *** MOVE this.products = this.productsService.getProducts() from the constructor to NgOnInit. ****
  -But now we realize the products are only being fetched ONE TIME, so it is not updating when a new item is added.
    - Go BACK to products.Services - so we can set up a SUBSCRIPTION to get informed about CHANGES.
    - Import: Subject from RjSX - its like an event emitter
    - 1st - create a new property in the service that is equal to a new Subject:
      productsUpdated = new Subject();
      - I want to emit an event through that Subject whenever the products array changes.
    - 2nd - in addProduct include: this.productsUpdated.next().
      - next is what calls the emit here, we can pass data with it too if we want too:
      this.productsUpdated.next(this.products) - but its unnecessary bc empty it'll trigger a new fetch.
    3rd - GO BACK TO ProductsComponent:
     - inside ngOnInit include: this.productsService.productsUpdated.subscribe().
      - ** this addition will now keep us informed about changes.
      - we just need to add the code we want it to run everytime to get the updates, which is the same as the first line of the ngOnInit!
      - we pass a function through subscribe where we get the value that was emitted, and then we define that code that should be executed whenever this triggers
        this.productsService.productsUpdated.subscribe(() => {
          this.products = this.productsService.getProducts();
        })
        - so now everytime the products change, this will run again.
    4th - go back to the top to IMPORT SUBSCRIPTION from rxjs.
      - Store Subscription in a property: private productsSubscription: Subscription
        (its TYPE is Subscription - remember you are using TypeScript, so include the TYPES)
      - Now that this productsSubscription and set our new ngOnInit function to it - it STORES it in the Subscription:
        this.productsSubscription = this.productsService.productsUpdated.subscribe(() => {
          this.products = this.productsService.getProducts();
        })
      ** the SUBSCRIBE method returns a new Subscription which is STORED in the productsSubscription
    5th - It is good practice to Destroy something that isn't used
    - import OnDestroy in the brackets from angular/core.
    - next to 'OnIt' on class ProductsComponent line put 'OnDestroy'
    - now can add a new method in the class called 'ngOnDestroy' which runs when its torn down.
      - so you need to reach out to your subscription and UNSUBSCRIBE.
      ngOnDestroy () {
        this.productsSubscription.unsubscribe();
      }
      - this clears up the resources and prevents memory leaks.
  Now we want to INJECT ProductsService into another component - ProductComponent
    AGAIN WE MUST (in product.component.ts):
     1. Import the productsService,
     2. set it as a variable and define the type,
     3. then run private productsService: ProductsService through the constructor
    In the onClicked function now we can reach out to the productsService and call "deleteProduct()" method there.
    - and pass this.productName so we know which one to delete.
      onClicked() {
        this.productsService.deleteProduct(this.productName)
      }
    - NOW we need to CREATE deleteProduct in our products.Service.ts
    - deleteProduct is inside our class
    - pass productName: string through the function because we need to know which one we are deleting.
    - this.products = this.products.fiter(p => p!== productName) because this gives us a new array WITHOUT the deleted productName
    - ALSO - this.productsUpdated(next) - this will trigger our SUBSCRIPTION with the 'next()' call so that our array of products is updated everytime something is deleted.

LECTURE 17 - Angular Routing
  - How our angular App has multiple pages even though only ONE is sent to the server.
  - Angular rerenders the ENTIRE page and It gives the illusion of loading a new page, even though everything was done by javascript.
    -*** This is FASTER than going back to the server and having the server send back a new page***
  - You can have Angular Autogenerate new COMPONENTS and SERVICES for you with this command:
    - ng g c Home or ng g s Home - c = component and s = service.
    - We are going to write notes for how you'd create your own tho just so we know what each part that is autogenerated means.
  - There is a class that is EXPORTED - and its the name of our component or service
    - We're making a new component = HomeComponent
  - @Component - decorator that goes above the class - (it will also be imported at the top)
    - inside component we will pass a template:
    template: '<h1>The Home Template</h1> - just an alternative, its a string that defines whats inside the template.
    ** When autogenerated its templateURL and it directs it to the html '/home.component.html'
    - You don't need a SELECTOR (inside the component decorator) when doing ROUTING.
  - AppModule.ts - The home component MUST BE: IMPORTED and added the @NgModules declarations section for evertying to connect.
  - CREATE - app-module.ts - This is where the routing goes.
  - add class AppRoutingModule
  - add @NgModule - since it is a module, (import it from Angular Core)
  - inside NgModule you want to create your routes, so you need to:
    - import Routes from angular routing package
    - now can create a const routes: Routes - with the type as Routes.
      - It requires an array of JS objects, where each object represents the configuration of one route.
      1st part: path - the part after the domain in your URL.
        - path: '' - represents the root route/homepage - no additional information is needed bc you want to be at the base html page.
        - component: HomeComponent - this is the component that should be loaded when this PATH is reached.
          - must import all the components at the top so the TS can find it
        ANOTHER EXAMPLE:
        - path: 'products' - your domain URL / products - dont add a / before it in quotes bc it is understood.
        - component: ProductsComponent - again main sure this component is imported at the top.
    - now we have some routing configuration, we just need to inform Angular about it
      - in @NgModule we use RouteModule - which is also imported from angular/router.
        - put it in the imports array of the NgModule and all the forRoot() method on it:
          RouteModule.forRoot(routes)
          - this finds the root route of our application
          - we pass the routes through it as an argument.
      - Now we need to add 'exports' to the NgModule
        - it takes an array from all the features of that module, like RouterModule, that we want to expose to other modules
          - aka expose it to the app.module.ts which will expose it to the entire app.
    - NEXT GO TO app.module.ts and IMPORT the app-routes.module.ts.
      - we do this at the top AND inside the NgModule imports array we add AppRoutingModule.
      - Angular is NOW AWARE of our routes.
    - LAST - need to tell Angular where to RENDER our ROUTES.
      - go into app.component.ts and instead of hard including the app-products page we'll use a special element a router-outlet.
      <router-outlet></router-outlet> is an HTML element, a DIRECTIVE coming from Angular and it:
        - MARKS THE PLACE IN YOUR DOCUMENT WHERE YOU WANT TO RENDER A ROUTE.
        - Any HTML above or below the page will not change when you go to the route - means you could have a header or navbar that is the same on ALL PAGES/ROUTES.
      - In the header element, we will create a routerLink to move between pages from the header element.
      - INSTEAD of href, use routerLink with the route in quotes:
      <h1>My Cool Header</h1>
      <a routerLink="/">Home</a> - these point to the path where we want to go.
      <a routerLink="/products">Products</a>
      <router-outlet></router-outlet>

Lecture 20 - Angular Material.
- A third part package for Angular
- An Angular Component Suite - a pre-built and Styled components
  - These components follow the Material design spec which was created by google.
  - This is so we can import buttons, tabs, dropdowns, etc so we don't have to create them totally on our own - can still change bits about their style in CSS.
- its almost like two packages:
1. Component Building Utilities
  - bundled in a package called angular/cdk (component development kit) and this does NOT INCUDE:
    -Angular Material Stlying, concrete component implementation.
    - instead it has alot of utility and helper methods and classes such as:
      - for rendering overlays, positioning elements, and some raw, unstyled components like a DATA TABLE - which is very complex behind the scenes.
2. Concrete Component Implementations (using Material Design Spec)
  - this is the one with all the angular Material components which are prestyled AND behind the scenes build up from/off of the cdk package.

Lecture 20 - Angular Material
- https://material.angular.io/ - has the CDK link where you can explore more and learn more about the features.
