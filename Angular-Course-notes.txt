1. Angular is a javascript framework, that uses TypeScript
    a. TypeScript - very similar to JS with alot of the same syntax, just it has some extra stuff:
    - still have: classes, properties, decorators, interfaces,
    b. Client side (Browser side) web applications
    - Single-Page-applications (SPAs) - its like a native-mobile-app-like User Experience
    c. highly-scalable, high performance,allows for you to build a big applications
    d. continuously developed and supported by google

2. Core Concepts
    a. one single HTML page (index.html) which is continuously re-rendered by angular
    b. the whole website is made up of components
        ex: header component, sidebar component, item component
        - in the end a component is just a template in which we have:
            - html code which in enhanced with special angular syntax.
            - typescript page - where we right the logic for the components
            - there are directives - allow us to manipulate the content of the template
                - *ngFor - four loops that can render huge amounts of code to a page
            - css & test pages are also autogenerated for each component.
    c. Services - these are needed to everything to communicate

3. Main.ts (src/main.ts - the main ts file that gets everything to run
  - import a few things from the angular package
  -
  - calls on AppModule on line 11 (and imports ir on line 4 from app/app.module )
    - its passed through bootstrapModule(AppModule) - which means start it on its own without any other help
      - here is the whole line - platformBrowserDynamic().bootstrapModule(AppModule)
    - AppModule is like the root file that defines all of the pieces that our Angular app is made up of
4. AppModule (scr/app/app.module.ts) -
  - we have imports, a type script class called AppModule that has no body, and @NgModule{}
  - @NgModule is a type of DECORATOR
    - ** A DECORATOR that is a ts feature that kind of manipulates the class (here AppModule) behind the scenes - it adds some metadata **
    - NgModule is a special decorator that is imported from the angular pacakge and it turns a normal type script class into a Module, its additional metadata allows it to be interpreted by Angular as a Model.
    - the object has declarations, imports, and providers that are DEFINITIONS/CONFIGURATIONS contain this metadata:
      - a declarations array declars all of the components that you are using in your project.
      - imports, imports other modules, like the BrowserModule seen here.
      - providers is used to provide services - something we'll come back to.
      - *bootstrap is a special one here bc it informs our app that AppComponent is the root component of the application
        - this is partially how it app.component is connected to the root-tag (app-root) in the index.html file.
        - if you go into app.component.ts you'll see in the Component decorator that selector is 'app-root'

Lecture 11 - ADDING COMPONENTS

1. App.component.ts CONTINUED...:
- A component is a building block of our app. each one is made of:
  - a typescript class that for app.component.ts is 'AppComponent'
  - a decorator called 'Component' decorator which is imported from angular core.
    - the decorator has metadata that makes the class more than just a class and is understood by Angular to be a component that should be rendered to the UI/screen.
    - 'templateUrl' - each component decorator must have this so there is content to actually render to the screen, bc it is the html file it is connected to.
      - this html file, its like html ++ bc it allows you to add special syntax like {{}} (string interpolation) which outputs dynamic content
    - 'styleURL' - which is optional, and points at the css file that is unique to this particular component.
    -'selector' maybe the most important - bc it is essentially the component's own 'HTML TAG'.
      - you can use this tag to put this component's template into other components' templates.

2. ng g c 'your component name here' will generate a component folder with:
  - the component ts, html, css and test files
  - it will connect it in app.modules.ts under @NgModule in declarations and import it there too so its called.
  - g is short for generate and c is short for component

3. String interpolation, event binding, property binding, Two way binding.
  - String interpolation - {{ prop }} - allows us to refer to a property (prop) of our typescript class and output its content in the html template
    - these props - which can be variables or fucntions - are located in the class component in the TS file.
    - they can be set dynamically in the class as well - example here uses setTimeout to have the variable change after 3 seconds.
  - event binding - an example is 'click', but there are LOTS - that is added the the html element:
    - <button (click)="">Click here</button>
      - between the " " - (click)="" - its not actually TEXT, its a reference to the function that should happen when the click takes place
      - ** the info between the "" is interpreted as type script code.
      - EX: (click)="productName = 'A Tree'" - when clicked product name changes to 'A Tree', need the single quotes to show the string that equals productName.
  - property binding - every html element has an underlying DOM element which is just a JS object with properties
    - ex: <button></button> has a built in property called 'disabled' which determines whether the button is disabled or not.
    - its sets the value of a property of an underlying dom object.
    - we can bind to that property by adding brackets around it and assign a dynamic prop/value to it too
      -<button (click)="productName = 'A Tree'" [disabled]="isDisabled">Click here</button>
      - in the TS you need to add property "isDisabled", if its set to "true" then it IS disabled and you can't click the button.
        - but maybe we use the setTimeout property so that button starts as isDisabled = true, but after 3 seconds we want to let the user click it so set isDisabled = false.
  - two way binding - combo of property AND event binding - so use [] and () = [()] and within we put [(ngModel)]
    - ngModel is a special directive provided by Angular.
    - <input type="text" [(ngModel)]="productName"> - this insures whatever us typed into the input will be updated by ngModel as the new productName
    - *** for ngModel to work *** must go to app.module.ts and first IMPORT it:
      -import {FormsModule} from 'angular/forms';
      - then inside go to NgModule DECORATOR and put it in the imports list.

LECTURE 12 - Directives: *ngFor & *ngIf
Structural directives that really change the structure of our page by adding and removing elements.
1. *ngFor:
  - currently our button just changes the current prop, it doesn't add anything.
  - change the button click to a function that adds a product instead of updating the productName property.
  <button (click)="onAddProduct()">Add Product</button> (inside products.component.html)
  - now we need to add the onAddProduct function as a method to the products.component.ts inside the class ProductsComponent.
  - because we want to add more than one product - we need to set a property equal to an array.
    - products = ['A Book', 'A Tree'] - this is still locating insde the class, above the constructor with the other variables.
  - Here is how the onAddProduct function looks:
    onAddProduct() {
      this.products.push(this.productName);
    }
    - this refers to the class ProductsComponent
    - we just created the products array
    - and we want to push the new productName into the products array - we have productName as the input.
  - Currently we have a single div to show the current productName.
  - BUT NOW we want to have a div autogenerated every time we add a new product.
  -** we will us a DIRECTIVE called *ngFor (aka a for loop).
    - the start *ngFor is required bc it tells the app that this is a structural directive that will change the app.
    - here is the language we MUST use:
    <div *ngFor="let product of products">{{ product }}</div>
    - let, just like es6 variables definitions,
    - product, totally up to you what you put here as the index for your array
    - of products, this is NOT up to you because it refers to the array you want to run the forloop through.
    - {{ product }} is where the individual 'product' of products will be placed.
    - so now each product within products will have its own div!

2. *ngIf
  - an *ngIf is based on a property that is true or false so a BOOLEAN.
  - IT ALLOWS US TO CONDITIONALLY RENDER SOMETHING - based on that boolean.
  - So for our example - we want to conditionally render our BUTTON.
  - we dont want to disable OR enable the button but we want to show it once "isDisabled" is false
  - *ngIf will ADD or REMOVE the html element it is placed into based on the boolean.
  here is our example with the button:
  <input *ngIf="!isDisabled" type="text" val[(ngModel)]="productName">
  <button *ngIf="!isDisabled" (click)="onAddProduct()">Add Product</button>
    - between the ngIf quotes we SPECIFY the CONDITION (it has to be somethign that returns TRUE or FALSE):
      - We want isDisabled to be false. so we put a ! infront of it to make it "not isDisabled" or reverse it.
      - we add this same ngIf to the button.
      - this works because in our products.component.ts the prop isDisabled is set to true
        -SO whenever isDisabled isn't itself (ie !isDisabled is is FALSE) the input and button will appear.
        - and our setTimeout will set isDisabled = false AFTER 3 seconds.
        - which means after 3 seconds, isDisabled will equal false AKA !isDisabled.

LECTURE 14 - Custom Property & Event Binding
* Now we want to put each of these new products we created into through own components -
  - That way we can add buttons, explanations, and alot more!
  - so we are going to grab the div we created and go to the product.component.html template
  - in the product.component.html we remove the ngFor and just have {{ productName}} within the div we created.
    - might at <p>An Awesome Product</p>
    - wrap the div and the p in the article element so we can add some styling - in product.component.css
    - <article class="product"> so in the css file we can call on product and change it some.
  - we add productName as a property in the product.component.ts under the class:
    - productName: string;
    - to get productName we need to go into product.component.ts (inside the class) and call on productName FROM ProductsComponent
    - ** we need to make it BINDABLE from outside, so we will use the [] brackets like we did for the html elements **
    - we do this with the "Input" decorator we also import from the angular/core package

  - Input: is a decorator imported from the angular/core **used to recieve data from the outside
    - place @Input() before the property you are trying to import from another component
      - @Input() productName: string;
    - now we can go into products.component.html and add:
    <app-product *ngFor="let product of products" [productName]="product"></app-product>
      - now "product" from our array is bound to the productName property and can be passed into the product.component
    - So the parent component can go into the child component this way
  - Now we'll add a click event so the child component can talk to the parent component.
  - in product.component.html add a click event to EVENTUALLY call on a function in the parent component (ProductsComponent).
    <article class="product" (click)="onClicked()">
    - 1ST - need to create onClicked function in the child (ProductComponent) ts file first
    ** this is where we'll call on a function in the parent component (ProductsComponent)
    - but to do this we need to import "EventEmitter" and "Output" from the angular core
  - EventEmitter: we emit our own custom events with it.
  - Output: another decorator - used to pass data to the outside
    **BACK TO product.component.ts**
    - first create our object that will be our new eventEmitter:
      productClicked = new EventEmitter();
      - to be able to listen to it from the outside we must add our Output decorator to the front:
      @Output() productClicked = new EventEmitter();
        - output is used here to pass our custom eventEmitter to products.component
    -now can finally create our onClicked function:
    onClicked() {
      this.productClicked.emit();
    }
    -NOW all we need to do is LISTEN to this event (productClicked) in ProductsComponent
      -once its there we can execute any code we want in the productsComponent:
      <app-product (productClicked)="onRemoveProduct(product)" *ngFor="let product of products" [productName]="product"></app-product>
      - we decided to call on "onRemoveProduct()" when the event emitter productClick is activated, and we are passing that product of products through it.
      - must creat this function onRemoveProduct in products.component.ts
        onRemoveProduct (productName: string) {
          this.products = this.products.filter(p => p !== productName);
        }
        - we know that product is equal to productName, and we call its type (string) bc its best practice and to make sure the function knows its type.
          ** this is a little confusing with the productName in product.component.ts - try not to worry to much about this**
        - we call on this.products (ProductsComponent.products) and then .filter it - it will do this function we create within the () on each item in the array.
        (p => p !== productName);
        - for each product only keep it if the product is NOT equal to productName. if it IS EQUAL we want to get rid of it.
        - that will create a NEW array and that is while the whole line is first set to "this.products ="
        - Now we can remove the books based on their name!

    - What we just did is custom event binding - common for cross-component communication.

